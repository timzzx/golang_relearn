# golang基础

## Go语言设计哲学

> 追求简单，少即是多

+ 简洁，常规语法（不需要解析符号表）
+ 内置垃圾收集，降低内存管理的心智负担
+ 没有头文件
+ 显式依赖(package)
+ 没有循环依赖(package)
+ 常量只是数字
+ 首字母大小写决定可见性
+ 没有子类型继承（没有子类）
+ 没有算术转换
+ 接口是隐式的（不需要implements声明）
+ 方法就是函数
+ 接口只是方法结合（没有数据）
+ 方法仅按名称匹配（不是按类型）
+ 没有构造函数和析构函数
+ n++和n--是语句，而不是表达式
+ 没有++n和--n
+ 赋值不是表达式
+ 在赋值和函数调用中定义的求值顺序（没有”序列点“概念）
+ 没有指针算术
+ 内存总是初始化为零值
+ 没有类型注解语法（比如 static public）
+ 没有异常（exception）
+ 内置字符串、切片、map类型
+ 内置数组边界检查
+ 内置并发支持

> 偏好组合，正交解耦

主流语言通过自上而下的类型体系、继承、显示接口将程序各部分耦合，go通过 **组合** 将各部分耦合。

Go正交语法:
+ Go无类型体系，类型之间是独立的，没有子类型
+ 每个类型都可以有自己的方法集合，类型定义和方法实现是正交独立的
+ 接口与其实现之间隐式关联
+ 包之间是相对独立的，没有子包的概念

Go组合方式
+ 类型嵌入（类似继承机制，但是原理上与其完全不同）
+ 被嵌入的类型和新类型之间没有任何关系（类型嵌入**垂直组合**）
+ 接口将程序各个部分组合起来（接口嵌入**水平组合**）
+ go + channel 的组合

总结，组合的应用塑造了Go程序的骨架接口。类型嵌入为类型提供垂直扩展的能力，接口是水平组合

> 原生并发，轻量高效（并发是有关结构的，而并行是有关执行的）

+ 采用轻量级协程并发模型
+ 并发的语法元素和机制
+ 并发原则

> 面向工程，”自带电池“

工程主要遇到的问题
+ 程序构建慢
+ 失控的依赖管理
+ 开发人员使用的编程语言的不同子集 （写法不一样）
+ 代码可理解性差（代码可读性差、文档差等）
+ 功能重复实现
+ 升级更新消耗大
+ 实现自动化工具难度高
+ 版本问题
+ 跨语言构建问题

## go语言原生编程思维

> 组合，并发


## 关键字
> go关键字25个

|关键字|含义|
|-|-|
|**>包管理<**|**2个**|
|import|包导入|
|package|包|
|**>声明和定义<**|**8个**|
|chan|通道|
|const|常量|
|func|函数|
|interface|接口|
|map|映射|
|struct|结构体|
|type|类型定义|
|var|声明|
|**>流程控制<**|**15个**|
|break|打断|
|case|分支|
|continue|继续|
|default|默认|
|defer|延迟|
|else|另外的|
|fallthrough|穿透|
|for|循环|
|go|协程|
|goto|转到|
|if|判断|
|range|区间|
|return|返回|
|select|选择，挑选|
|switch|切换|

## 内置类型

|名称|含义|
|-|-|
|**>值类型<**||
|bool|布尔|
|int(32或64)|有符号|
|int8|8位|
|int16|16位|
|int32|32位|
|int64|64位|
|uint(32或64)|无符号|
|uint8别名byte|8位|
|uint16|16位|
|uint32|32位|
|uint64|64位|
|float32|浮点32位|
|float64|浮点64位|
|array|数组|
|**>引用类型<**||
|slice|切片|
|map|映射|
|chan|通道|

## 内置函数
> 有一些一般用不到的函数就不记录了

|名称|含义|
|-|-|
|append|数组，切片，追加元素|
|close|关闭通道|
|delete|删除映射中key和对应的value|
|panic|异常|
|recover|恢复异常|
|make|分配内存 切片，映射，通道|
|new|分配内存，主要是Type类型的指针|
|cap|容量，切片和映射|
|copy|用于复制和连接切片|
|len|长度，字符串，数组，切片，映射，通道|
|print,println|打印，一般还是使用fmt包|


## 尽量定义零值可用的类型
> 零值不仅在变量初始化阶段避免了变量值不确定可能带来的潜在问题，定义零值可用类型是**最佳实践之一**

go语言每个原生类型都有默认值，这就是类型的零值

+ 所有整数类型：0
+ 浮点类型：0.0
+ 布尔类型：false
+ 字符串类型：""
+ 指针、interface、切片、channel、map、function：nil

> 零值可用
保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用

## 使用复合字面值作为初值构造器
```go
s := MyStuct{"tony",18}
a := [5]int{1,2,3,4,5}
sl := []int{1,2,3}
m := map[int]string{1:"aa",2:"bb"}
```

## 切片
### 先说数组

+ 数组是固定长度的、容纳同构类型元素的连续序列
+ 数组类型两个属性：元素类型和数组长度
+ 数组是值语义的，**数组的变量表示的是整个数组**
+ 传递数组是纯粹的值copy
+ go中最多的还是使用切片

### 切片说明
+ 切片对于数组相当于文件描述符对于文件
+ 切片是数组的一个操作窗口

切片内部结构（以水壶为例）
+ 地址 （水壶放的位置）
+ 长度 （水壶里面有多少水）
+ 容量 （水壶能装多少水）

### 切片声明和初始化

+ 切片只有一种声明方式，与数组类似，但不指定大小
    + 声明 var 
    + 切片有三种初始化方式
        + 切片作为初始化值
        + 数组作为初始化值
        + make函数返回值作为初始化值

> 注意事项
+ 切片声明后不能直接使用，需要引用到一个数组，或者make初始化，**原因就是切片的零值是nil，nil是没有地址的所以需要初始化才能使用（这样就和上面内置类型零值关联上了）**
+ 不能越界使用

```go
package main

import "fmt"

func main() {
	// 声明 空切片 未初始化
	var s1 []int
	// 空切片 未初始化
	s2 := []int{}
	// 有数据的切片
	s3 := []int{1}
	// // make创建切片，省略cap, cap=len
	s4 := make([]int, 2)
	// // make创建切片，分别定义了len,cap
	s5 := make([]int, 2, 3)
	fmt.Println("s1", s1)
	// fmt.Println("s1内存地址:", &s1[0]) // panic: runtime error: index out of range [0] with length 0
	fmt.Println("s2", s2)
	// fmt.Println("s2内存地址:", &s2[0]) // panic: runtime error: index out of range [0] with length 0
	fmt.Println("s3", s3)
	fmt.Println("s3内存地址:", &s3[0]) // s3内存地址: 0xc0000160a0
	fmt.Println("s4:", s4, "内存地址", &s4[0], "len:", len(s4), "cap:", cap(s4))
	fmt.Println("s5:", s5, "内存地址", &s5[0], "len:", len(s5), "cap:", cap(s5))
}

```

### 切片化

> 这个要理解两个词 slicing，reslicing

+ slicing **切片化** 针对数组 array[low:high]
+ reslicing **切片重组** 针对切片 slice[low:high]

通过切片化数组返回的就是切片了。这里要注意**切片化和切片重组得到的切片**
+ 切片地址 addr &s[low]
+ 长度 len	high-low
+ 容量 cap  array|slice cap - low

### 切片动态扩容
+ 使用append函数追加扩容，让切片类型满足了”零值可用“
+ 尽量使用cap创建切片
+ 当需要的容量超过原切片容量的两倍时，会使用需要的容量作为新容量。
+ 当原切片长度小于1024时，新切片的容量会直接翻倍。而当原切片的容量大于等于1024时，会反复地增加25%，直到新容量超过所需要的容量。

> 切片是数组的描述符，大多数场合代替了数组，减少了数组指针作为函数参数的使用 

## map映射

> map[key]value 不支持零值可用，和切片一样，零值为nil，需要初始化才能使用

### map初始化
